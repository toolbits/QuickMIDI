#include <Threads.h>#include <QuickTimeMusic.h>#include <MIDI.h>#define			ZeroVariable						(long)0#define			ZeroPointer							(long)0#define			ZeroHandle							(long)0#define			NoteAllocatorPolyphony				2#define			NoteAllocatorTypicalPolyphony		0x00010000#define			NowActiveRPN						1#define			NowActiveNRPN						0#define			MaxMIDIChannel						16typedef struct AudioMIDIxManagerStatic{	NoteAllocator		NoteAllocatorDevice;	NoteChannel			MIDIChannel[MaxMIDIChannel];} AudioMIDIxManagerStatic,*AudioMIDIxManagerStaticPtr,**AudioMIDIxManagerStaticHandle;typedef struct MIDIxDataAccess{	Boolean				InterruptNoteAllocator;		Boolean				GSDeviceOn;	Byte				BankGS;		Byte				ActiveRPN[2][MaxMIDIChannel];	Byte				ActiveNRPN[2][MaxMIDIChannel];	short				ActiveXRPNMode[MaxMIDIChannel];	Boolean				MultiDrum[MaxMIDIChannel];	short				ActiveInstrument[MaxMIDIChannel];	long				PitchBendRange[MaxMIDIChannel];	short				LevelMonitor[MaxMIDIChannel];	short				LockLevel[MaxMIDIChannel];		short				AutoResetStatus;	long				AutoResetTime;	long				AutoResetLimit;} MIDIxDataAccess,*MIDIxDataAccessPtr,**MIDIxDataAccessHandle;//GlobalRoutinesComponentResult			SetupNoteAllocator				(void);void					ResetNoteAllocator				(void);pascal			short	ReadRoutine						(register MIDIPacketPtr,register long);void					ResetMidiDevice					(void);pascal			void	ThreadRoutine					(void);void					IdleMidiStatus					(void);void					ResetNotes						(void);void					ResetControls					(void);void					ResetInstruments				(void);//StaticRoutinesstatic			void	MidiWorkRoutine					(void);static			void	InterruptResetMidiDevice		(void);static			void	SystemExclusive					(register Byte[16]);static			void	ResetZeroXRPNSystem				(void);static			void	ResetZeroLevelMonitor			(void);static			void	ResetZeroGMInstrument			(void);static			void	InterruptResetZeroGMInstrument	(void);static			void	ResetZeroPitchBendRange			(void);static			void	NANoteRoutine					(register short,register long,register long);static			void	NAPolyPressureRoutine			(register short,register long,register long);static			void	NAControllerRoutine				(register short,register long,register long);static			void	NAProgramRoutine				(register short,register long);static			void	NAProgramInterruptRoutine		(register short,register long);static			void	NAChannelPressureRoutine		(register short,register long);static			void	NAPitchBendRoutine				(register short,register long,register long);//ExternRoutinesextern			void	DrawLevelBar					(register short[16]);extern			void	DrawAboutMessage				(register short[16]);extern			Boolean	GetAutoResetOn					(void);extern			short	GetAutoResetSec					(void);extern			Boolean	GetMultiDrumOn					(void);extern			Boolean	GetOnlyUseStandardOn			(void);//StaticMemoriesstatic			AudioMIDIxManagerStatic					AudioMIDIxManagerGlobal;static			MIDIxDataAccess							MIDIxAccess;//ExternMemoriesextern			Boolean									AboutMessageOn;ComponentResult SetupNoteAllocator(void){	NoteRequest						NewNoteType;	register			short		ID;	ComponentResult					ResultCode;		ResultCode = noErr;	if((AudioMIDIxManagerGlobal.NoteAllocatorDevice = OpenDefaultComponent(kNoteAllocatorComponentType,ZeroVariable)) != ZeroVariable){		NewNoteType.info.polyphony = NoteAllocatorPolyphony;		NewNoteType.info.typicalPolyphony = NoteAllocatorTypicalPolyphony;		if((ResultCode = NAStuffToneDescription(AudioMIDIxManagerGlobal.NoteAllocatorDevice,kFirstGMInstrument,&(NewNoteType.tone))) == noErr){			for(ID=0;ID<MaxMIDIChannel;ID++){				if((ResultCode = NANewNoteChannel(AudioMIDIxManagerGlobal.NoteAllocatorDevice,&NewNoteType,&(AudioMIDIxManagerGlobal.MIDIChannel[ID]))) != noErr){					for(ID=ID-1;ID>=0;ID--) NADisposeNoteChannel(AudioMIDIxManagerGlobal.NoteAllocatorDevice,AudioMIDIxManagerGlobal.MIDIChannel[ID]);					break;				}			}		}		if(ResultCode != noErr) CloseComponent(AudioMIDIxManagerGlobal.NoteAllocatorDevice);	}	else ResultCode = (ComponentResult)-1;	return(ResultCode);}/*SetupNoteAllocator*/void ResetNoteAllocator(void){	register			short		ID;	for(ID=0;ID<MaxMIDIChannel;ID++){		NAResetNoteChannel(AudioMIDIxManagerGlobal.NoteAllocatorDevice,AudioMIDIxManagerGlobal.MIDIChannel[ID]);		NADisposeNoteChannel(AudioMIDIxManagerGlobal.NoteAllocatorDevice,AudioMIDIxManagerGlobal.MIDIChannel[ID]);	}	CloseComponent(AudioMIDIxManagerGlobal.NoteAllocatorDevice);	return;}/*ResetNoteAllocator*/pascal short ReadRoutine(register MIDIPacketPtr MIDIEventBlock,register long Reference){	register	long		SaveA5Address;	register	short		DataByteOne;		SaveA5Address = SetA5(Reference);		if((MIDIEventBlock->flags & midiTypeMask) == 0){		DataByteOne = MIDIEventBlock->data[0];				switch(DataByteOne&0xF0){			case 0x80:				if(MIDIEventBlock->len == 9){					NANoteRoutine(DataByteOne&0x0F,MIDIEventBlock->data[1],0);					MIDIxAccess.LockLevel[DataByteOne & 0x0F] = 0;				}				break;			case 0x90:				if(MIDIEventBlock->len == 9){					NANoteRoutine(DataByteOne&0x0F,MIDIEventBlock->data[1],MIDIEventBlock->data[2]);					MIDIxAccess.LockLevel[DataByteOne & 0x0F] = MIDIEventBlock->data[2]/11;				}				break;			case 0xA0:				if(MIDIEventBlock->len == 9){					NAPolyPressureRoutine(DataByteOne&0x0F,MIDIEventBlock->data[1],MIDIEventBlock->data[2]);				}				break;			case 0xB0:				if(MIDIEventBlock->len == 9){					NAControllerRoutine(DataByteOne&0x0F,MIDIEventBlock->data[1],MIDIEventBlock->data[2]);				}				break;			case 0xC0:				if(MIDIEventBlock->len == 8){					NAProgramInterruptRoutine(DataByteOne&0x0F,MIDIEventBlock->data[1]);				}				break;			case 0xD0:				if(MIDIEventBlock->len == 8){					NAChannelPressureRoutine(DataByteOne&0x0F,MIDIEventBlock->data[1]);				}				break;			case 0xE0:				if(MIDIEventBlock->len == 9){					NAPitchBendRoutine(DataByteOne&0x0F,MIDIEventBlock->data[1],MIDIEventBlock->data[2]);				}				break;			case 0xF0:			case 0xF7:				SystemExclusive(&(MIDIEventBlock->data[1]));				break;			default:				break;		}				if(MIDIxAccess.AutoResetStatus == 0) MIDIxAccess.AutoResetStatus = 1;		MIDIxAccess.AutoResetTime = 0;		MIDIxAccess.AutoResetLimit = 0;		MIDIxAccess.InterruptNoteAllocator = true;	}		SetA5(SaveA5Address);	return(midiMorePacket);}/*ReadRoutine*/static void SystemExclusive(register Byte Data[16]){	register	short		DrumTrack;				if(Data[3] == 0x12 && Data[4] == 0x40 && Data[6] == 0x15){								//Sub Drum Channel		if(GetMultiDrumOn() == true){			DrumTrack = Data[5] & 0x0F;			if(DrumTrack == 0x00) DrumTrack = 0x09;			else if(DrumTrack <= 0x09) DrumTrack--;			MIDIxAccess.MultiDrum[DrumTrack] = true;			NAProgramInterruptRoutine(DrumTrack,0);		}	}	else if(Data[3] == 0x12 && Data[4] == 0x40 && Data[5] == 0x00 && Data[6] == 0x7F){		//GS All Reset		MIDIxAccess.GSDeviceOn = true;		InterruptResetMidiDevice();	}	else if(Data[0] == 0x7E && Data[1] == 0x7F && Data[2] == 0x09 && Data[3] == 0x01){		//GM System On		MIDIxAccess.GSDeviceOn = false;		InterruptResetMidiDevice();	}	else if(Data[0] == 0x7E && Data[1] == 0x7F && Data[2] == 0x09 && Data[3] == 0x02){		//GM System Off		MIDIxAccess.GSDeviceOn = true;		InterruptResetMidiDevice();	}	return;}/*SystemExclusive*/void ResetMidiDevice(void){	MIDIxAccess.GSDeviceOn = true;	ResetZeroXRPNSystem();	ResetZeroLevelMonitor();	ResetZeroGMInstrument();	ResetZeroPitchBendRange();		MIDIxAccess.AutoResetStatus = 0;	MIDIxAccess.AutoResetTime = 0;	MIDIxAccess.AutoResetLimit = 0;	return;}/*ResetMidiDevice*/static void InterruptResetMidiDevice(void){	ResetZeroXRPNSystem();	ResetZeroLevelMonitor();	InterruptResetZeroGMInstrument();	ResetZeroPitchBendRange();		MIDIxAccess.AutoResetStatus = 0;	MIDIxAccess.AutoResetTime = 0;	MIDIxAccess.AutoResetLimit = 0;	return;}/*InterruptResetMidiDevice*/pascal void ThreadRoutine(void){	while(true){		MidiWorkRoutine();		YieldToAnyThread();											//Thread Entry	}	return;}/*ThreadRoutine*/void IdleMidiStatus(void){	MidiWorkRoutine();	return;}/*IdleMidiStatus*/static void MidiWorkRoutine(void){	static		long		SaveTicks = 0;	static		long		SaveResetTicks = 0;		register	short		ID;		if(MIDIxAccess.InterruptNoteAllocator == true){		NATask(AudioMIDIxManagerGlobal.NoteAllocatorDevice);		MIDIxAccess.InterruptNoteAllocator = false;	}		if(SaveTicks < LMGetTicks()){		for(ID=0;ID<MaxMIDIChannel;ID++) if(MIDIxAccess.LevelMonitor[ID] < MIDIxAccess.LockLevel[ID]) MIDIxAccess.LevelMonitor[ID] = MIDIxAccess.LockLevel[ID];				if(AboutMessageOn == true) DrawAboutMessage(MIDIxAccess.LevelMonitor);		else DrawLevelBar(MIDIxAccess.LevelMonitor);				for(ID=0;ID<MaxMIDIChannel;ID++){			if(MIDIxAccess.LevelMonitor[ID] > 0) MIDIxAccess.LevelMonitor[ID]--;			if(MIDIxAccess.LockLevel[ID] > 0) MIDIxAccess.LockLevel[ID]--;		}		SaveTicks = LMGetTicks();	}		if(GetAutoResetOn() == true){		if(MIDIxAccess.AutoResetStatus == 1){			SaveResetTicks = LMGetTicks();			MIDIxAccess.AutoResetStatus = 2;			MIDIxAccess.AutoResetTime = 0;			MIDIxAccess.AutoResetLimit = 0;		}		if(MIDIxAccess.AutoResetStatus == 2){			if(SaveResetTicks < LMGetTicks()){				MIDIxAccess.AutoResetLimit += LMGetTicks() - SaveResetTicks;				if(MIDIxAccess.AutoResetLimit > 59){					MIDIxAccess.AutoResetTime++;					MIDIxAccess.AutoResetLimit -= 60;					if(MIDIxAccess.AutoResetTime > GetAutoResetSec()){						SysBeep(0);						ResetNotes();						MIDIxAccess.AutoResetStatus = 0;					}				}				SaveResetTicks = LMGetTicks();			}		}	}	else MIDIxAccess.AutoResetStatus = 0;	return;}/*MidiWorkRoutine*//****************************************************************************************************/////										NA Menu Proc///****************************************************************************************************/void ResetNotes(void){	register		short		ID;	register		short		Index;		for(Index=0;Index<MaxMIDIChannel;Index++) for(ID=0;ID<128;ID++) NAPlayNote(AudioMIDIxManagerGlobal.NoteAllocatorDevice,AudioMIDIxManagerGlobal.MIDIChannel[Index],ID,0);	ResetZeroLevelMonitor();	return;}/*ResetNotes*/void ResetControls(void){	register		short		Index;		for(Index=0;Index<MaxMIDIChannel;Index++) NAResetNoteChannel(AudioMIDIxManagerGlobal.NoteAllocatorDevice,AudioMIDIxManagerGlobal.MIDIChannel[Index]);	ResetZeroPitchBendRange();	ResetZeroXRPNSystem();	ResetZeroLevelMonitor();	return;}/*ResetControls*/void ResetInstruments(void){	register		short		ID;		for(ID=0;ID<MaxMIDIChannel;ID++){		MIDIxAccess.MultiDrum[ID] = (ID == 9) ? true : false;		NAProgramRoutine(ID,0);	}	return;}/*ResetInstruments*//****************************************************************************************************/////										NA Utilities///****************************************************************************************************/static void ResetZeroXRPNSystem(void){	register		short		ID;		for(ID=0;ID<MaxMIDIChannel;ID++){		MIDIxAccess.ActiveRPN[0][ID] = 0xFF;		MIDIxAccess.ActiveRPN[1][ID] = 0xFF;		MIDIxAccess.ActiveNRPN[0][ID] = 0xFF;		MIDIxAccess.ActiveNRPN[1][ID] = 0xFF;		MIDIxAccess.ActiveXRPNMode[ID] = 0xFFFF;	}	return;}/*ResetZeroXRPNSystem*/static void ResetZeroLevelMonitor(void){	register		short		ID;		for(ID=0;ID<MaxMIDIChannel;ID++){		MIDIxAccess.LevelMonitor[ID] = 0;		MIDIxAccess.LockLevel[ID] = 0;	}	return;}/*ResetZeroLevelMonitor*/static void ResetZeroGMInstrument(void){	register		short		ID;		MIDIxAccess.BankGS = 0;	for(ID=0;ID<MaxMIDIChannel;ID++){		MIDIxAccess.MultiDrum[ID] = (ID == 9) ? true : false;		NAProgramRoutine(ID,0);		NAResetNoteChannel(AudioMIDIxManagerGlobal.NoteAllocatorDevice,AudioMIDIxManagerGlobal.MIDIChannel[ID]);	}	return;}/*ResetZeroGMInstrument*/static void InterruptResetZeroGMInstrument(void){	register		short		ID;		MIDIxAccess.BankGS = 0;	for(ID=0;ID<MaxMIDIChannel;ID++){		MIDIxAccess.MultiDrum[ID] = (ID == 9) ? true : false;		NAProgramInterruptRoutine(ID,0);		NAResetNoteChannel(AudioMIDIxManagerGlobal.NoteAllocatorDevice,AudioMIDIxManagerGlobal.MIDIChannel[ID]);	}	return;}/*InterruptResetZeroGMInstrument*/static void ResetZeroPitchBendRange(void){	register		short		ID;		for(ID=0;ID<MaxMIDIChannel;ID++) MIDIxAccess.PitchBendRange[ID] = 2;	return;}/*ResetZeroPitchBendRange*/static void NANoteRoutine(register short ActiveChannel,register long PitchBend,register long Velocity){	NAPlayNote(AudioMIDIxManagerGlobal.NoteAllocatorDevice,AudioMIDIxManagerGlobal.MIDIChannel[ActiveChannel],PitchBend,Velocity);	return;}/*NoteRoutine*/static void NAPolyPressureRoutine(register short ActiveChannel,register long ID,register long Variable){	return;}/*NAPolyPressureRoutine*/static void NAControllerRoutine(register short ActiveChannel,register long ControlID,register long ControlVariable){	register		short		ID;		if(ControlID <= 32 || ControlID > 63){		switch(ControlID){			case 0:																//Bank Select GS				MIDIxAccess.BankGS = ControlVariable;				break;			case 32:															//Bank Select GM/GS				if(ControlVariable == 0){					MIDIxAccess.GSDeviceOn = true;					//GS ‚È‚Ì‚É GM System On ‚ª‘—‚ç‚ê‚½Žž				}				else if(ControlVariable == 1){					MIDIxAccess.BankGS = 0;							//GM Mode				}				else if(ControlVariable == 2){					MIDIxAccess.GSDeviceOn = true;					//GS ‚È‚Ì‚É GM System On ‚ª‘—‚ç‚ê‚½Žž				}				break;			case 99:				MIDIxAccess.ActiveNRPN[0][ActiveChannel] = (Byte)ControlVariable;				MIDIxAccess.ActiveXRPNMode[ActiveChannel] = NowActiveNRPN;				break;			case 98:				MIDIxAccess.ActiveNRPN[1][ActiveChannel] = (Byte)ControlVariable;				MIDIxAccess.ActiveXRPNMode[ActiveChannel] = NowActiveNRPN;				break;			case 101:				MIDIxAccess.ActiveRPN[0][ActiveChannel] = (Byte)ControlVariable;				MIDIxAccess.ActiveXRPNMode[ActiveChannel] = NowActiveRPN;				break;			case 100:				MIDIxAccess.ActiveRPN[1][ActiveChannel] = (Byte)ControlVariable;				MIDIxAccess.ActiveXRPNMode[ActiveChannel] = NowActiveRPN;				break;			case 6:				if(MIDIxAccess.ActiveXRPNMode[ActiveChannel] == NowActiveRPN){					if(MIDIxAccess.ActiveRPN[0][ActiveChannel] == 0 && MIDIxAccess.ActiveRPN[1][ActiveChannel] == 0) MIDIxAccess.PitchBendRange[ActiveChannel] = ControlVariable;				}				break;			case 121:				for(ID=0;ID<MaxMIDIChannel;ID++) NAResetNoteChannel(AudioMIDIxManagerGlobal.NoteAllocatorDevice,AudioMIDIxManagerGlobal.MIDIChannel[ID]);				break;			case 120:			case 123:				for(ID=0;ID<128;ID++) NAPlayNote(AudioMIDIxManagerGlobal.NoteAllocatorDevice,AudioMIDIxManagerGlobal.MIDIChannel[ActiveChannel],ID,0);				break;			case kControllerPan:				NASetController(AudioMIDIxManagerGlobal.NoteAllocatorDevice,AudioMIDIxManagerGlobal.MIDIChannel[ActiveChannel],kControllerPan,ControlVariable*2+256);				break;			default:				if(ControlID < 98) NASetController(AudioMIDIxManagerGlobal.NoteAllocatorDevice,AudioMIDIxManagerGlobal.MIDIChannel[ActiveChannel],ControlID,ControlVariable*256);				break;		}	}	return;}/*NAControllerRoutine*/static void NAProgramRoutine(register short ActiveChannel,register long InstrumentID){	register		short		ID;	if(MIDIxAccess.MultiDrum[ActiveChannel] == true){		if(GetOnlyUseStandardOn() == true) InstrumentID = 0;		InstrumentID += kFirstDrumkit;	}	else{		if(MIDIxAccess.GSDeviceOn == true) InstrumentID += MIDIxAccess.BankGS * 128;	}	InstrumentID += kFirstGMInstrument;		if(MIDIxAccess.ActiveInstrument[ActiveChannel] != InstrumentID){		for(ID=0;ID<128;ID++) NAPlayNote(AudioMIDIxManagerGlobal.NoteAllocatorDevice,AudioMIDIxManagerGlobal.MIDIChannel[ActiveChannel],ID,0);		NASetInstrumentNumber(AudioMIDIxManagerGlobal.NoteAllocatorDevice,AudioMIDIxManagerGlobal.MIDIChannel[ActiveChannel],InstrumentID);		MIDIxAccess.ActiveInstrument[ActiveChannel] = InstrumentID;	}	return;}/*NAProgramRoutine*/static void NAProgramInterruptRoutine(register short ActiveChannel,register long InstrumentID){	register		short		ID;	if(MIDIxAccess.MultiDrum[ActiveChannel] == true){		if(GetOnlyUseStandardOn() == true) InstrumentID = 0;		InstrumentID += kFirstDrumkit;	}	else{		if(MIDIxAccess.GSDeviceOn == true) InstrumentID += MIDIxAccess.BankGS * 128;	}	InstrumentID += kFirstGMInstrument;		if(MIDIxAccess.ActiveInstrument[ActiveChannel] != InstrumentID){		for(ID=0;ID<128;ID++) NAPlayNote(AudioMIDIxManagerGlobal.NoteAllocatorDevice,AudioMIDIxManagerGlobal.MIDIChannel[ActiveChannel],ID,0);		NASetInstrumentNumberInterruptSafe(AudioMIDIxManagerGlobal.NoteAllocatorDevice,AudioMIDIxManagerGlobal.MIDIChannel[ActiveChannel],InstrumentID);		MIDIxAccess.InterruptNoteAllocator = true;		MIDIxAccess.ActiveInstrument[ActiveChannel] = InstrumentID;	}	return;}/*NAProgramInterruptRoutine*/static void NAChannelPressureRoutine(register short ActiveChannel,register long PressureVariable){	NASetController(AudioMIDIxManagerGlobal.NoteAllocatorDevice,AudioMIDIxManagerGlobal.MIDIChannel[ActiveChannel],kControllerAfterTouch,PressureVariable*256);	return;}/*NAChannelPressureRoutine*/static void NAPitchBendRoutine(register short ActiveChannel,register long PitchBendVariableOne,register long PitchBendVariableTwo){	register		long		PitchBendVariable;		PitchBendVariable = (PitchBendVariableOne + (PitchBendVariableTwo - (long)64) * (long)128) * MIDIxAccess.PitchBendRange[ActiveChannel] / (long)32;	NASetController(AudioMIDIxManagerGlobal.NoteAllocatorDevice,AudioMIDIxManagerGlobal.MIDIChannel[ActiveChannel],kControllerPitchBend,PitchBendVariable);	return;}/*NAPitchBendRoutine*/